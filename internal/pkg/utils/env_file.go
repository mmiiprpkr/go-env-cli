package utils

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"gopkg.in/yaml.v3"
)

// EnvFile represents environment variables from a file
type EnvFile struct {
	Variables map[string]string
}

// NewEnvFile creates a new EnvFile instance
func NewEnvFile() *EnvFile {
	return &EnvFile{
		Variables: make(map[string]string),
	}
}

// ParseFromFile parses environment variables from a file based on its extension
func (e *EnvFile) ParseFromFile(filePath string) error {
	ext := strings.ToLower(filepath.Ext(filePath))

	switch ext {
	case ".env", "":
		return e.parseEnvFile(filePath)
	case ".json":
		return e.parseJSONFile(filePath)
	case ".yaml", ".yml":
		return e.parseYAMLFile(filePath)
	default:
		return fmt.Errorf("unsupported file format: %s", ext)
	}
}

// parseEnvFile parses a .env file
func (e *EnvFile) parseEnvFile(filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open env file: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "//") {
			continue
		}

		// Parse key-value pairs
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			return fmt.Errorf("invalid format at line %d: %s (expected key=value)", lineNum, line)
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// Remove quotes if present
		if len(value) >= 2 && ((value[0] == '"' && value[len(value)-1] == '"') ||
			(value[0] == '\'' && value[len(value)-1] == '\'')) {
			value = value[1 : len(value)-1]
		}

		e.Variables[key] = value
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("error reading env file: %w", err)
	}

	return nil
}

// parseJSONFile parses a JSON file containing environment variables
func (e *EnvFile) parseJSONFile(filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open JSON file: %w", err)
	}
	defer file.Close()

	var jsonVars map[string]interface{}
	if err := json.NewDecoder(file).Decode(&jsonVars); err != nil {
		return fmt.Errorf("failed to parse JSON file: %w", err)
	}

	// Flatten the JSON into key-value pairs
	e.flattenJSON("", jsonVars)

	return nil
}

// flattenJSON flattens a nested JSON object into key-value pairs
func (e *EnvFile) flattenJSON(prefix string, jsonMap map[string]interface{}) {
	for k, v := range jsonMap {
		key := k
		if prefix != "" {
			key = prefix + "_" + key
		}

		// Convert key to uppercase for env vars
		key = toSnakeCase(key)

		switch val := v.(type) {
		case map[string]interface{}:
			// Recursively process nested objects
			e.flattenJSON(key, val)
		case []interface{}:
			// Convert arrays to JSON strings
			bytes, err := json.Marshal(val)
			if err == nil {
				e.Variables[key] = string(bytes)
			}
		case string, float64, bool, int, int64, nil:
			// Convert primitive values to strings
			e.Variables[key] = fmt.Sprintf("%v", val)
		}
	}
}

// parseYAMLFile parses a YAML file containing environment variables
func (e *EnvFile) parseYAMLFile(filePath string) error {
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open YAML file: %w", err)
	}
	defer file.Close()

	var yamlVars map[string]interface{}
	if err := yaml.NewDecoder(file).Decode(&yamlVars); err != nil {
		return fmt.Errorf("failed to parse YAML file: %w", err)
	}

	// Flatten the YAML into key-value pairs
	e.flattenJSON("", yamlVars)

	return nil
}

// WriteToFile writes environment variables to a file in the specified format
func (e *EnvFile) WriteToFile(filePath string) error {
	ext := strings.ToLower(filepath.Ext(filePath))

	switch ext {
	case ".env", "":
		return e.writeEnvFile(filePath)
	case ".json":
		return e.writeJSONFile(filePath)
	case ".yaml", ".yml":
		return e.writeYAMLFile(filePath)
	default:
		return fmt.Errorf("unsupported file format: %s", ext)
	}
}

// writeEnvFile writes a .env file
func (e *EnvFile) writeEnvFile(filePath string) error {
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create env file: %w", err)
	}
	defer file.Close()

	// Write header
	file.WriteString("# Generated by go-env-cli\n\n")

	// Write variables sorted by key
	keys := make([]string, 0, len(e.Variables))
	for k := range e.Variables {
		keys = append(keys, k)
	}

	// Sort keys alphabetically
	// strings.Sort(keys)

	for _, k := range keys {
		v := e.Variables[k]
		formattedValue := FormatEnvValue(v)
		file.WriteString(fmt.Sprintf("%s=%s\n", k, formattedValue))
	}

	return nil
}

// writeJSONFile writes a JSON file
func (e *EnvFile) writeJSONFile(filePath string) error {
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create JSON file: %w", err)
	}
	defer file.Close()

	// Convert environment variables to JSON structure
	jsonStruct := make(map[string]interface{})
	for k, v := range e.Variables {
		jsonStruct[k] = v
	}

	// Write JSON with indentation
	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(jsonStruct); err != nil {
		return fmt.Errorf("failed to write JSON file: %w", err)
	}

	return nil
}

// writeYAMLFile writes a YAML file
func (e *EnvFile) writeYAMLFile(filePath string) error {
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create YAML file: %w", err)
	}
	defer file.Close()

	// Convert environment variables to YAML structure
	yamlStruct := make(map[string]interface{})
	for k, v := range e.Variables {
		yamlStruct[k] = v
	}

	// Write YAML
	encoder := yaml.NewEncoder(file)
	if err := encoder.Encode(yamlStruct); err != nil {
		return fmt.Errorf("failed to write YAML file: %w", err)
	}

	return nil
}

// toSnakeCase converts a string to UPPER_SNAKE_CASE for environment variables
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, c := range s {
		if unicode.IsUpper(c) && i > 0 {
			result.WriteRune('_')
		}
		result.WriteRune(unicode.ToUpper(c))
	}

	// Replace any non-alphanumeric characters with underscores
	str := result.String()
	str = strings.Map(func(r rune) rune {
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' {
			return '_'
		}
		return r
	}, str)

	// Replace multiple underscores with a single one
	for strings.Contains(str, "__") {
		str = strings.ReplaceAll(str, "__", "_")
	}

	return str
}
